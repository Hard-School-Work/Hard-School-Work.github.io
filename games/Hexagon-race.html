<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>School Work</title>
<link rel="icon" type="svg" href="https://upload.wikimedia.org/wikipedia/commons/thumb/1/19/Google_Classroom_Logo.svg/1024px-Google_Classroom_Logo.svg.png?20221017163738">
<link rel="stylesheet" href="../style.css">

<style>
  html, body {
    margin: 0;
    padding: 0;
    width: 100%;
    height: 100%;
    overflow: hidden;
    background: black;
  }

  iframe {
    width: 100%;
    height: 100%;
    border: none;
    display: block;
  }

  /* Click-to-start overlay */
  #clickOverlay {
    position: fixed;
    inset: 0;
    background: black;
    color: #fff;
    display: flex;
    align-items: center;
    justify-content: center;
    font: bold 26px Arial;
    cursor: pointer;
    z-index: 9999;
  }
</style>
</head>

<body>

<iframe id="gameFrame" allowfullscreen></iframe>

<div id="clickOverlay">
  CLICK ANYWHERE TO START
</div>

<script>
/* ==========================
     INDEXED DB CACHING
========================== */

const DB_NAME = 'GameCacheDB';
const STORE_NAME = 'GameFiles';
const CACHE_DURATION = 90 * 24 * 60 * 60 * 1000; // 90 days
const FILE_URL = 'https://cdn.jsdelivr.net/gh/netclassroom/felek@main/googlx6.xml';

function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);

    request.onupgradeneeded = e => {
      e.target.result.createObjectStore(STORE_NAME, { keyPath: 'url' });
    };

    request.onsuccess = e => resolve(e.target.result);
    request.onerror = e => reject(e.target.error);
  });
}

async function saveToCache(url, content) {
  const db = await openDB();

  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readwrite');
    const store = tx.objectStore(STORE_NAME);

    store.put({
      url,
      content,
      timestamp: Date.now()
    }).onsuccess = resolve;

    tx.onerror = () => reject("Cache write error");
  });
}

async function getFileFromCache(url) {
  const db = await openDB();

  return new Promise((resolve, reject) => {
    const tx = db.transaction(STORE_NAME, 'readonly');
    const store = tx.objectStore(STORE_NAME);

    store.get(url).onsuccess = async (e) => {
      const data = e.target.result;

      // Use valid cached copy
      if (data && (Date.now() - data.timestamp) < CACHE_DURATION) {
        resolve(data.content);
        return;
      }

      // Fetch fresh copy
      try {
        const res = await fetch(url);
        const text = await res.text();
        await saveToCache(url, text);
        resolve(text);
      } catch (err) {
        reject(err);
      }
    };

    tx.onerror = () => reject("Cache read error");
  });
}


/* ==========================
      LOAD GAME
========================== */

const frame = document.getElementById("gameFrame");

async function loadGame() {
  try {
    const html = await getFileFromCache(FILE_URL);
    frame.contentDocument.open();
    frame.contentDocument.write(html);
    frame.contentDocument.close();
  } catch (err) {
    console.error(err);
    alert("Game failed to load.");
  }
}


/* ==========================
   CLICK â†’ FULLSCREEN + START
========================== */

const overlay = document.getElementById("clickOverlay");

overlay.addEventListener("click", async () => {

  // Go fullscreen
  if (!document.fullscreenElement) {
    try {
      await document.documentElement.requestFullscreen();
    } catch(e){}
  }

  // Remove overlay
  overlay.remove();

  // Load game
  loadGame();

});
</script>

</body>
</html>
