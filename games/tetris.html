<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Tetris</title>
    <style>
        canvas {
            position: absolute;
            top: 45%;
            left: 50%;
            width: 640px;
            height: 640px;
            margin: -320px 0 0 -320px;
            background-color: #DDEEFF;
        }
    </style>
</head>
<body>
<canvas></canvas>
<script>
'use strict';

const canvas = document.querySelector('canvas');
canvas.width = 640;
canvas.height = 640;
const g = canvas.getContext('2d');

// Grid settings
const nRows = 18, nCols = 12;
const EMPTY = -1, BORDER = -2;
const blockSize = 30;
const topMargin = 50, leftMargin = 20;
const colors = ['green', 'red', 'blue', 'purple', 'orange', 'blueviolet', 'magenta'];
let grid = [];

// Shape movement directions
const right = {x: 1, y: 0}, left = {x: -1, y: 0}, down = {x: 0, y: 1};

// Game variables
let fallingShape = null;
let nextShape = null;
let fallingShapeRow = 0;
let fallingShapeCol = 0;
let keyDown = false;
let fastDown = false;

// Scoreboard
class Scoreboard {
    constructor() {
        this.level = 0;
        this.lines = 0;
        this.score = 0;
        this.topscore = 0;
        this.gameOver = true;
    }
    reset() { this.level = this.lines = this.score = 0; this.gameOver = false; }
    setGameOver() { this.gameOver = true; }
    isGameOver() { return this.gameOver; }
    addScore(sc) { this.score += sc; }
    addLines(line) {
        switch(line) {
            case 1: this.addScore(10); break;
            case 2: this.addScore(20); break;
            case 3: this.addScore(30); break;
            case 4: this.addScore(40); break;
        }
        this.lines += line;
        if(this.lines >= 10) { this.level++; this.lines %= 10; }
    }
    getScore() { return this.score; }
    getLines() { return this.lines; }
    getLevel() { return this.level; }
    getTopscore() { return this.topscore; }
    getSpeed() { return 700 - this.level * 60; } // simple speed formula
}
const scoreboard = new Scoreboard();

// Shapes
const Shapes = {
    ZShape: [[0,-1],[0,0],[-1,0],[-1,1]],
    SShape: [[0,-1],[0,0],[1,0],[1,1]],
    IShape: [[0,-1],[0,0],[0,1],[0,2]],
    TShape: [[-1,0],[0,0],[1,0],[0,1]],
    Square: [[0,0],[1,0],[0,1],[1,1]],
    LShape: [[-1,-1],[0,-1],[0,0],[0,1]],
    JShape: [[1,-1],[0,-1],[0,0],[0,1]]
};

class Shape {
    constructor(shape, type) {
        this.shape = shape;
        this.type = type;
        this.pos = shape.map(p => [...p]);
        this.ordinal = Object.keys(Shapes).indexOf(type);
    }
    reset() { this.pos = this.shape.map(p => [...p]); }
}

// Random shape
function getRandomShape() {
    const keys = Object.keys(Shapes);
    const key = keys[Math.floor(Math.random() * keys.length)];
    return new Shape(Shapes[key], key);
}

// Initialize grid
function initGrid() {
    grid = [];
    for (let r=0;r<nRows;r++) {
        grid[r] = [];
        for (let c=0;c<nCols;c++) {
            if(c===0 || c===nCols-1 || r===nRows-1) grid[r][c]=BORDER;
            else grid[r][c]=EMPTY;
        }
    }
}

// Movement checks
function canMove(s, dir) {
    return s.pos.every(p => {
        const newRow = fallingShapeRow + dir.y + p[1];
        const newCol = fallingShapeCol + dir.x + p[0];
        return grid[newRow][newCol] === EMPTY;
    });
}

function move(dir) { fallingShapeRow += dir.y; fallingShapeCol += dir.x; }

function canRotate(s) {
    if(s.type==='Square') return false;
    const pos = s.pos.map(p => [...p]).map(p => [p[1], -p[0]]);
    return pos.every(p => grid[fallingShapeRow + p[1]][fallingShapeCol + p[0]] === EMPTY);
}

function rotate(s) {
    if(s.type==='Square') return;
    s.pos = s.pos.map(p => [p[1], -p[0]]);
}

function shapeHasLanded() {
    fallingShape.pos.forEach(p => grid[fallingShapeRow+p[1]][fallingShapeCol+p[0]] = fallingShape.ordinal);
    const lines = removeLines();
    scoreboard.addLines(lines);
    if(fallingShapeRow < 2) scoreboard.setGameOver();
    selectShape();
}

function removeLines() {
    let count=0;
    for(let r=0;r<nRows-1;r++) {
        if(grid[r].slice(1,nCols-1).every(cell => cell!==EMPTY)) {
            for(let c=1;c<nCols-1;c++) grid[r][c]=EMPTY;
            for(let rr=r; rr>0; rr--) for(let c=1;c<nCols-1;c++) grid[rr][c]=grid[rr-1][c];
            count++;
        }
    }
    return count;
}

// Select new shape
function selectShape() {
    fallingShape = nextShape;
    nextShape = getRandomShape();
    if(fallingShape) fallingShape.reset();
    fallingShapeRow = 1;
    fallingShapeCol = 5;
}

// Drawing
function drawSquare(idx,r,c) {
    g.fillStyle = colors[idx];
    g.fillRect(leftMargin+c*blockSize,topMargin+r*blockSize,blockSize,blockSize);
    g.strokeStyle='white';
    g.lineWidth=2;
    g.strokeRect(leftMargin+c*blockSize,topMargin+r*blockSize,blockSize,blockSize);
}

function draw() {
    g.clearRect(0,0,canvas.width,canvas.height);
    // Draw grid
    for(let r=0;r<nRows;r++) for(let c=0;c<nCols;c++) {
        if(grid[r][c]>=0) drawSquare(grid[r][c],r,c);
    }
    // Draw falling shape
    if(fallingShape) {
        fallingShape.pos.forEach(p => drawSquare(fallingShape.ordinal, fallingShapeRow+p[1], fallingShapeCol+p[0]));
    }
    // Draw next shape preview
    if(nextShape) {
        let cx = 467, cy = 97;
        let minX=Math.min(...nextShape.pos.map(p=>p[0]));
        let minY=Math.min(...nextShape.pos.map(p=>p[1]));
        let maxX=Math.max(...nextShape.pos.map(p=>p[0]));
        let maxY=Math.max(...nextShape.pos.map(p=>p[1]));
        const offsetX = cx - ((minX+maxX+1)/2*blockSize);
        const offsetY = cy - ((minY+maxY+1)/2*blockSize);
        g.save();
        g.translate(offsetX, offsetY);
        nextShape.pos.forEach(p => drawSquare(nextShape.ordinal, p[1], p[0]));
        g.restore();
    }
    // Score
    g.fillStyle='black';
    g.font='18px monospace';
    g.fillText('score: '+scoreboard.getScore(),400,330);
    g.fillText('level: '+scoreboard.getLevel(),400,360);
    g.fillText('lines: '+scoreboard.getLines(),400,390);
}

// Input
addEventListener('keydown', e=>{
    if(!keyDown){
        keyDown=true;
        if(scoreboard.isGameOver()) return;
        switch(e.key){
            case 'ArrowUp': case 'w': if(canRotate(fallingShape)) rotate(fallingShape); break;
            case 'ArrowLeft': case 'a': if(canMove(fallingShape,left)) move(left); break;
            case 'ArrowRight': case 'd': if(canMove(fallingShape,right)) move(right); break;
            case 'ArrowDown': case 's':
                if(!fastDown){ fastDown=true; while(canMove(fallingShape,down)) move(down); shapeHasLanded(); }
                break;
        }
        draw();
    }
});

addEventListener('keyup', e => { keyDown=false; fastDown=false; });
addEventListener('click', startNewGame);

// Animation loop
function animate() {
    if(scoreboard.isGameOver()) return;
    if(canMove(fallingShape, down)) move(down);
    else shapeHasLanded();
    draw();
    setTimeout(animate, scoreboard.getSpeed());
}

// Start game
function startNewGame() {
    initGrid();
    nextShape = getRandomShape();
    fallingShape = null;
    scoreboard.reset();
    selectShape();
    draw();
    animate();
}

// Initial draw
initGrid();
nextShape = getRandomShape();
draw();

</script>
</body>
</html>
